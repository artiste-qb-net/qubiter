

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>qubiter.adv_applications.MeanHamilMinimizer module &mdash; qubiter 1.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> qubiter
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
        
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="rosetta.html">Rosetta Stone</a></li>
<li class="toctree-l1"><a class="reference internal" href="classgraph.html">Class Graph</a></li>
</ul>

            
          
        <a href="py-modindex.html">Module Index</a>
    
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">qubiter</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>qubiter.adv_applications.MeanHamilMinimizer module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/qubiter.adv_applications.MeanHamilMinimizer.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-qubiter.adv_applications.MeanHamilMinimizer">
<span id="qubiter-adv-applications-meanhamilminimizer-module"></span><h1>qubiter.adv_applications.MeanHamilMinimizer module<a class="headerlink" href="#module-qubiter.adv_applications.MeanHamilMinimizer" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="qubiter.adv_applications.MeanHamilMinimizer.MeanHamilMinimizer">
<em class="property">class </em><code class="sig-prename descclassname">qubiter.adv_applications.MeanHamilMinimizer.</code><code class="sig-name descname">MeanHamilMinimizer</code><span class="sig-paren">(</span><em class="sig-param">emp_mhamil</em>, <em class="sig-param">targ_mhamil</em>, <em class="sig-param">all_var_nums</em>, <em class="sig-param">init_var_num_to_rads</em>, <em class="sig-param">print_hiatus=1</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/qubiter/adv_applications/MeanHamilMinimizer.html#MeanHamilMinimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qubiter.adv_applications.MeanHamilMinimizer.MeanHamilMinimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="qubiter.adv_applications.CostMinimizer.html#qubiter.adv_applications.CostMinimizer.CostMinimizer" title="qubiter.adv_applications.CostMinimizer.CostMinimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">qubiter.adv_applications.CostMinimizer.CostMinimizer</span></code></a></p>
<p>This class is a child of class CostMinimizer. It’s purpose is to
minimize a cost function which equals the mean value of a Hamiltonian.
We refer to this task as the Mean Hamiltonian Minimization Problem.</p>
<p>The qc history of this problem started with quantum chemists planning to
use on a qc the phase estimation algo invented by Kitaev? (an algo that
is also implemented in Qubiter) to estimate the energy levels (
eigenvalues) of simple molecules, initially H2. Then a bunch of people
realized, heck, rather than trying to estimate the eigenvalues of a
Hamiltonian by estimating the phase changes it causes, we can estimate
those eigenvalues more efficiently by estimating the mean value of that
Hamiltonian as measured empirically on a qc. Basically, just the
Rayleigh-Ritz method, one of the oldest tricks in the book. One of the
first papers to propose this mean idea is
<a class="reference external" href="https://arxiv.org/abs/1304.3061">https://arxiv.org/abs/1304.3061</a> Their algo is commonly referred to by
the ungainly name VQE (Variational Quantum Eigensolver). VQE was
originally applied to do quantum chemistry with a qc. But now Rigetti
and others have renamed it hybrid quantum-classical quantum computing
and pointed out that it’s an algo that has wide applicability, not just
to quantum chemistry.</p>
<p>The idea behind hybrid quantum-classical is very simple. One has a
classical box CBox and a quantum box QBox. The gates of QBox depend on N
gate parameters. QBox sends info to CBox. CBox sends back to QBox N new
gate parameters that will lower some cost function. This feedback
process between CBox and QBox continues until the cost is minimized. The
cost function is the mean value of a Hamiltonian which is estimated
empirically from data obtained from the qc which resides inside the QBox.</p>
<p>To minimize a function of N continuous parameters, one can use some
methods like simulated annealing and Powell that do not require
calculating derivatives, or one can use methods that do use derivatives.
Another possible separation is between methods that don’t care which
local minimum they find, as long as they find one of them, and those
methods that try to find the best local minimum of them all, the so
called global minimum. Yet another separation is between methods that
allow constraints and those that don’t.</p>
<p>Among the methods that do use derivatives, the so called gradient based
methods only use the 1st derivative, whereas other methods use both
first (Jacobian) and second (Hessian) derivatives. The performance of
those that use both 1st and 2nd derivatives degrades quickly as N grows.
Besides, calculating 2nd derivatives is very expensive. Hence, methods
that use the 2nd derivatives are practically useless in the neural
network field where N is usually very large. In that field, gradient
based methods rule.</p>
<p>A method that uses no derivatives is Powell. A gradient based method
that is designed to have a fast convergence rate is the Conjugate
Gradient (CG) method. Another gradient based method is back-propagation
(BP). BP can be implemented as distributed computing much more easily
than other gradient based methods so it is favored by the most popular
computer programs for doing distributed AI, such as PyTorch and
TensorFlow.</p>
<p>Qubiter can perform minimization using various minlibs (minimization
software libraries) such as ‘scipy’, ‘autograd’, ‘tflow’, ‘pytorch’. It
can also use various devices (aka simulators or backends), either
virtual or real, to do the minimization. For example, tensorflow is a
minlib and SEO_simulator_tf is a backend that is native to qubiter and
uses tensorflow. By a native device, we mean one that uses Qubiter
native simulators like SEO_simulator and SEO_simulator_tf.</p>
<p>Non-scipy minlibs implement backprop.</p>
<p>The ‘scipy’ minlib is a wrapper for the scipy function
<cite>scipy.optimize.minimize</cite>. This scipy umbrella method implements many
minimization methods, including Powell and CG.</p>
<p><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>all_var_nums</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – this is a list of distinct ints that identify each continuous
variable (i.e., parameter, non-functional placeholder variable) on
which the cost function depends. The ordering corresponds to the
ordering of self.init_x_val</p></li>
<li><p><strong>emp_mhamil</strong> (<a class="reference internal" href="qubiter.adv_applications.MeanHamil.html#qubiter.adv_applications.MeanHamil.MeanHamil" title="qubiter.adv_applications.MeanHamil.MeanHamil"><em>MeanHamil</em></a>) – Empirical mean Hamiltonian, used to evaluate cost</p></li>
<li><p><strong>init_x_val</strong> (<em>nm.ndarray</em>) – this array gives the initial values in radians for the cost function
being minimized. The ordering corresponds to the ordering of
self.all_var_nums</p></li>
<li><p><strong>targ_mhamil</strong> (<a class="reference internal" href="qubiter.adv_applications.MeanHamil.html#qubiter.adv_applications.MeanHamil.MeanHamil" title="qubiter.adv_applications.MeanHamil.MeanHamil"><em>MeanHamil</em></a>) – Target mean Hamiltonian, used to evaluate targ_cost</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="qubiter.adv_applications.MeanHamilMinimizer.MeanHamilMinimizer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">emp_mhamil</em>, <em class="sig-param">targ_mhamil</em>, <em class="sig-param">all_var_nums</em>, <em class="sig-param">init_var_num_to_rads</em>, <em class="sig-param">print_hiatus=1</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/qubiter/adv_applications/MeanHamilMinimizer.html#MeanHamilMinimizer.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qubiter.adv_applications.MeanHamilMinimizer.MeanHamilMinimizer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>emp_mhamil</strong> (<a class="reference internal" href="qubiter.adv_applications.MeanHamil.html#qubiter.adv_applications.MeanHamil.MeanHamil" title="qubiter.adv_applications.MeanHamil.MeanHamil"><em>MeanHamil</em></a>) – </p></li>
<li><p><strong>targ_mhamil</strong> (<a class="reference internal" href="qubiter.adv_applications.MeanHamil.html#qubiter.adv_applications.MeanHamil.MeanHamil" title="qubiter.adv_applications.MeanHamil.MeanHamil"><em>MeanHamil</em></a>) – </p></li>
<li><p><strong>all_var_nums</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – </p></li>
<li><p><strong>init_var_num_to_rads</strong> (<em>dict</em><em>[</em><em>int</em><em>, </em><em>float</em><em>]</em>) – </p></li>
<li><p><strong>print_hiatus</strong> (<em>int</em>) – </p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="qubiter.adv_applications.MeanHamilMinimizer.MeanHamilMinimizer.cost_fun">
<code class="sig-name descname">cost_fun</code><span class="sig-paren">(</span><em class="sig-param">x_val</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/qubiter/adv_applications/MeanHamilMinimizer.html#MeanHamilMinimizer.cost_fun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qubiter.adv_applications.MeanHamilMinimizer.MeanHamilMinimizer.cost_fun" title="Permalink to this definition">¶</a></dt>
<dd><p>This method wraps self.emp_mhamil.get_mean_val(). This method will
also print out, whenever it is called, a report of the current
values of x and cost (and targ_cost if it is available).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x_val</strong> (<em>np.ndarray</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="qubiter.adv_applications.MeanHamilMinimizer.MeanHamilMinimizer.find_min">
<code class="sig-name descname">find_min</code><span class="sig-paren">(</span><em class="sig-param">minlib</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/qubiter/adv_applications/MeanHamilMinimizer.html#MeanHamilMinimizer.find_min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qubiter.adv_applications.MeanHamilMinimizer.MeanHamilMinimizer.find_min" title="Permalink to this definition">¶</a></dt>
<dd><p>This method finds minimum of cost function. It allows user to choose
among several possible minlibs, namely, ‘scipy’, ‘autograd’,
‘tflow’, ‘pytorch’. minlib parameters can be passed in via kwargs.</p>
<p>kwargs (keyword arguments)
minlib = scipy</p>
<blockquote>
<div><p>the keyword args of scipy.optimize.minimize</p>
</div></blockquote>
<dl class="simple">
<dt>minlib = autograd, tflow</dt><dd><dl class="simple">
<dt>num_inter<span class="classifier">float</span></dt><dd><p>number of iterations (an iteration is every time call
cost_fun)</p>
</dd>
<dt>descent_rate<span class="classifier">float</span></dt><dd><p>positive float, constant that multiplies gradient of cost
function being minimized. Often denoted as eta</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>minlib</strong> (<em>str</em>) – </p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>OptimizeResult is a class (basically an enum) defined in
scipy.optimize to hold the output results of
scipy.optimize.minimize</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>OptimizeResult | None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="qubiter.adv_applications.MeanHamilMinimizer.MeanHamilMinimizer.targ_cost_fun">
<code class="sig-name descname">targ_cost_fun</code><span class="sig-paren">(</span><em class="sig-param">x_val</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/qubiter/adv_applications/MeanHamilMinimizer.html#MeanHamilMinimizer.targ_cost_fun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qubiter.adv_applications.MeanHamilMinimizer.MeanHamilMinimizer.targ_cost_fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the cost, predicted from theory, rather than estimated from
data as in cost_fun(). This method mimics the method cost_fun(),
but that one wraps self.emp_mhamil.get_mean_val(). This one wraps
self.targ_mhamil.get_mean_val().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x_val</strong> (<em>np.ndarray</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Robert R. Tucci &amp; Qubiter contributors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>