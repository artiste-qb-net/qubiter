from qubiter.PlaceholderManager import *


class LoopyPlaceholderManager(PlaceholderManager):
    """
    This class is important to you only if you are interested in using loops
    in the English file.

    This class is a child of PlaceholderManager. Like its parent
    PlaceholderManager, it stores and processes info having to do with
    placeholder variables.

    This class in used by class LoopFileGenerator to write a Loop File,
    which is a template Python file that when modified by you and executed,
    generates the history of each placeholder variable ( either a hash
    variable or a functional placeholder) used in a target circuit with
    nested loops.

    A history of a variable is a list of all the values it will assume all
    the times it is used in the circuit (each repetition in a loop or nested
    loops is counted as a different use.)

    Variables with a _li suffix are one item lists. This is a way of passing
    by reference (i.e., by pointer) instead of by value, an immutable in
    Python.

    Attributes
    ----------
    indentation_li : list[int]
        one item list containing an int that stores the current number
        of indentation spaces in the Loop File being written
    loop_out : _io.TextIOWrapper
        out stream to Loop File being generated by collaboration of this
        class and a LoopFileManager. This class writes to loop_out info
        stored in it

    """

    def __init__(self, loop_out, indentation_li, **kwargs):
        """
        Constructor

        Parameters
        ----------
        loop_out : _io.TextIOWrapper
        indentation_li : list[int]
        kwargs : dict

        Returns
        -------

        """
        PlaceholderManager.__init__(self, **kwargs)
        self.loop_out = loop_out
        self.indentation_li = indentation_li

    def degs_str_to_rads(self, degs_str, line_count):
        """
        This method overrides method of same name in parent class
        PlaceholderManager. This method is called by class SEO_reader every
        time a placeholder with a legal name is encountered while reading an
        input English file. This method analyzes the legal name and writes
        info gleaned from that analysis to the Loop File being written.

        Parameters
        ----------
        degs_str : str
        line_count : int

        Returns
        -------
        float | str

        """
        if PlaceholderManager.is_legal_var_name(degs_str):
            is_fun_var = PlaceholderManager.is_functional_var(degs_str)
            fun_name = PlaceholderManager.get_leg_var_fun_name(degs_str)
            var_num_list = PlaceholderManager.get_leg_var_var_nums(degs_str)

            # store var numbers
            for var_num in var_num_list:
                if var_num not in self.all_var_nums:
                    self.all_var_nums.append(var_num)

            # store function name
            if fun_name:
                if fun_name not in self.all_fun_names:
                    self.all_fun_names.append(fun_name)

            append_str = '.append(None' + '\n' + \
                    ' ' * self.indentation_li[0] +\
                    ')  # ' + degs_str + ', line ' + \
                    str(line_count) + '\n'

            for var_num in var_num_list:
                self.loop_out.write(' ' * self.indentation_li[0] +
                    'var_num_to_hist[' + str(var_num) +
                    "]" + append_str)

            if is_fun_var:
                self.loop_out.write(' ' * self.indentation_li[0] +
                    'fun_name_to_hist["' + fun_name +
                    '"]' + append_str)

    def write_loop_file_prelude(self):
        """
        This method writes stuff at the beginning of the Loop File, before
        the English file has been read.


        Returns
        -------
        None

        """
        pass

    def write_loop_file_ending(self):
        """
        This method writes stuff at the end of the Loop File, after the
        English file has been read.

        Returns
        -------
        None

        """
        self.loop_out.write('\n')
        # it's important not to redefine all_var_nums and all_fun_names here
        #  so that they pass their values out of the exec()
        self.loop_out.write('all_var_nums += ' +
                            str(self.all_var_nums) + "\n")
        self.loop_out.write('all_fun_names += ' +
                            str(self.all_fun_names) + "\n")


if __name__ == "__main__":
    def main():
        print(5)
    main()
